/* FSMC.cpp
   Generated by gSOAP 2.7.14 from FileSetMan.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "FSMH.h"

namespace FSM {

SOAP_SOURCE_STAMP("@(#) FSMC.cpp ver 2.7.14 2010-01-24 13:27:27 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_FSM_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_FSM_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_FSM_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_FSM_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_FSM_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_FSM_ns1__File:
		return soap_in_ns1__File(soap, NULL, NULL, "ns1:File");
	case SOAP_TYPE_FSM_ns1__ArrayOfFile:
		return soap_in_ns1__ArrayOfFile(soap, NULL, NULL, "ns1:ArrayOfFile");
	case SOAP_TYPE_FSM_ns1__FileSet:
		return soap_in_ns1__FileSet(soap, NULL, NULL, "ns1:FileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitErrorResponse:
		return soap_in_PointerTo_ns1__CommitErrorResponse(soap, NULL, NULL, "ns1:CommitErrorResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitError:
		return soap_in_PointerTo_ns1__CommitError(soap, NULL, NULL, "ns1:CommitError");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileResponse:
		return soap_in_PointerTo_ns1__CommitFileResponse(soap, NULL, NULL, "ns1:CommitFileResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFile:
		return soap_in_PointerTo_ns1__CommitFile(soap, NULL, NULL, "ns1:CommitFile");
	case SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotifyResponse:
		return soap_in_PointerTo_ns1__ProgressNotifyResponse(soap, NULL, NULL, "ns1:ProgressNotifyResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotify:
		return soap_in_PointerTo_ns1__ProgressNotify(soap, NULL, NULL, "ns1:ProgressNotify");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSetResponse:
		return soap_in_PointerTo_ns1__CommitFileSetResponse(soap, NULL, NULL, "ns1:CommitFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSet:
		return soap_in_PointerTo_ns1__CommitFileSet(soap, NULL, NULL, "ns1:CommitFileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSetResponse:
		return soap_in_PointerTo_ns1__DeleteFileSetResponse(soap, NULL, NULL, "ns1:DeleteFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSet:
		return soap_in_PointerTo_ns1__DeleteFileSet(soap, NULL, NULL, "ns1:DeleteFileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSetResponse:
		return soap_in_PointerTo_ns1__QureyFileSetResponse(soap, NULL, NULL, "ns1:QureyFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSet:
		return soap_in_PointerTo_ns1__QureyFileSet(soap, NULL, NULL, "ns1:QureyFileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSetResponse:
		return soap_in_PointerTo_ns1__CreateFileSetResponse(soap, NULL, NULL, "ns1:CreateFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSet:
		return soap_in_PointerTo_ns1__CreateFileSet(soap, NULL, NULL, "ns1:CreateFileSet");
	case SOAP_TYPE_FSM_PointerTons1__FileSet:
		return soap_in_PointerTons1__FileSet(soap, NULL, NULL, "ns1:FileSet");
	case SOAP_TYPE_FSM_PointerTons1__File:
		return soap_in_PointerTons1__File(soap, NULL, NULL, "ns1:File");
	case SOAP_TYPE_FSM_PointerTons1__ArrayOfFile:
		return soap_in_PointerTons1__ArrayOfFile(soap, NULL, NULL, "ns1:ArrayOfFile");
	case SOAP_TYPE_FSM_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_FSM__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_FSM_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_FSM_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:File"))
		{	*type = SOAP_TYPE_FSM_ns1__File;
			return soap_in_ns1__File(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfFile"))
		{	*type = SOAP_TYPE_FSM_ns1__ArrayOfFile;
			return soap_in_ns1__ArrayOfFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FileSet"))
		{	*type = SOAP_TYPE_FSM_ns1__FileSet;
			return soap_in_ns1__FileSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_FSM_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_FSM_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_FSM_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_FSM_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_FSM__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_FSM_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CommitErrorResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__CommitErrorResponse;
			return soap_in__ns1__CommitErrorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommitError"))
		{	*type = SOAP_TYPE_FSM__ns1__CommitError;
			return soap_in__ns1__CommitError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommitFileResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__CommitFileResponse;
			return soap_in__ns1__CommitFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommitFile"))
		{	*type = SOAP_TYPE_FSM__ns1__CommitFile;
			return soap_in__ns1__CommitFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProgressNotifyResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__ProgressNotifyResponse;
			return soap_in__ns1__ProgressNotifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProgressNotify"))
		{	*type = SOAP_TYPE_FSM__ns1__ProgressNotify;
			return soap_in__ns1__ProgressNotify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommitFileSetResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__CommitFileSetResponse;
			return soap_in__ns1__CommitFileSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommitFileSet"))
		{	*type = SOAP_TYPE_FSM__ns1__CommitFileSet;
			return soap_in__ns1__CommitFileSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteFileSetResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__DeleteFileSetResponse;
			return soap_in__ns1__DeleteFileSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteFileSet"))
		{	*type = SOAP_TYPE_FSM__ns1__DeleteFileSet;
			return soap_in__ns1__DeleteFileSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QureyFileSetResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__QureyFileSetResponse;
			return soap_in__ns1__QureyFileSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QureyFileSet"))
		{	*type = SOAP_TYPE_FSM__ns1__QureyFileSet;
			return soap_in__ns1__QureyFileSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateFileSetResponse"))
		{	*type = SOAP_TYPE_FSM__ns1__CreateFileSetResponse;
			return soap_in__ns1__CreateFileSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateFileSet"))
		{	*type = SOAP_TYPE_FSM__ns1__CreateFileSet;
			return soap_in__ns1__CreateFileSet(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_FSM_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_FSM_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_FSM_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_FSM_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_FSM_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_FSM__ns1__CommitErrorResponse:
		return ((_ns1__CommitErrorResponse *)ptr)->soap_out(soap, "ns1:CommitErrorResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__CommitError:
		return ((_ns1__CommitError *)ptr)->soap_out(soap, "ns1:CommitError", id, NULL);
	case SOAP_TYPE_FSM__ns1__CommitFileResponse:
		return ((_ns1__CommitFileResponse *)ptr)->soap_out(soap, "ns1:CommitFileResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__CommitFile:
		return ((_ns1__CommitFile *)ptr)->soap_out(soap, "ns1:CommitFile", id, NULL);
	case SOAP_TYPE_FSM__ns1__ProgressNotifyResponse:
		return ((_ns1__ProgressNotifyResponse *)ptr)->soap_out(soap, "ns1:ProgressNotifyResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__ProgressNotify:
		return ((_ns1__ProgressNotify *)ptr)->soap_out(soap, "ns1:ProgressNotify", id, NULL);
	case SOAP_TYPE_FSM__ns1__CommitFileSetResponse:
		return ((_ns1__CommitFileSetResponse *)ptr)->soap_out(soap, "ns1:CommitFileSetResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__CommitFileSet:
		return ((_ns1__CommitFileSet *)ptr)->soap_out(soap, "ns1:CommitFileSet", id, NULL);
	case SOAP_TYPE_FSM__ns1__DeleteFileSetResponse:
		return ((_ns1__DeleteFileSetResponse *)ptr)->soap_out(soap, "ns1:DeleteFileSetResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__DeleteFileSet:
		return ((_ns1__DeleteFileSet *)ptr)->soap_out(soap, "ns1:DeleteFileSet", id, NULL);
	case SOAP_TYPE_FSM__ns1__QureyFileSetResponse:
		return ((_ns1__QureyFileSetResponse *)ptr)->soap_out(soap, "ns1:QureyFileSetResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__QureyFileSet:
		return ((_ns1__QureyFileSet *)ptr)->soap_out(soap, "ns1:QureyFileSet", id, NULL);
	case SOAP_TYPE_FSM__ns1__CreateFileSetResponse:
		return ((_ns1__CreateFileSetResponse *)ptr)->soap_out(soap, "ns1:CreateFileSetResponse", id, NULL);
	case SOAP_TYPE_FSM__ns1__CreateFileSet:
		return ((_ns1__CreateFileSet *)ptr)->soap_out(soap, "ns1:CreateFileSet", id, NULL);
	case SOAP_TYPE_FSM_ns1__File:
		return ((ns1__File *)ptr)->soap_out(soap, tag, id, "ns1:File");
	case SOAP_TYPE_FSM_ns1__ArrayOfFile:
		return ((ns1__ArrayOfFile *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfFile");
	case SOAP_TYPE_FSM_ns1__FileSet:
		return ((ns1__FileSet *)ptr)->soap_out(soap, tag, id, "ns1:FileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitErrorResponse:
		return soap_out_PointerTo_ns1__CommitErrorResponse(soap, tag, id, (_ns1__CommitErrorResponse *const*)ptr, "ns1:CommitErrorResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitError:
		return soap_out_PointerTo_ns1__CommitError(soap, tag, id, (_ns1__CommitError *const*)ptr, "ns1:CommitError");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileResponse:
		return soap_out_PointerTo_ns1__CommitFileResponse(soap, tag, id, (_ns1__CommitFileResponse *const*)ptr, "ns1:CommitFileResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFile:
		return soap_out_PointerTo_ns1__CommitFile(soap, tag, id, (_ns1__CommitFile *const*)ptr, "ns1:CommitFile");
	case SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotifyResponse:
		return soap_out_PointerTo_ns1__ProgressNotifyResponse(soap, tag, id, (_ns1__ProgressNotifyResponse *const*)ptr, "ns1:ProgressNotifyResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotify:
		return soap_out_PointerTo_ns1__ProgressNotify(soap, tag, id, (_ns1__ProgressNotify *const*)ptr, "ns1:ProgressNotify");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSetResponse:
		return soap_out_PointerTo_ns1__CommitFileSetResponse(soap, tag, id, (_ns1__CommitFileSetResponse *const*)ptr, "ns1:CommitFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSet:
		return soap_out_PointerTo_ns1__CommitFileSet(soap, tag, id, (_ns1__CommitFileSet *const*)ptr, "ns1:CommitFileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSetResponse:
		return soap_out_PointerTo_ns1__DeleteFileSetResponse(soap, tag, id, (_ns1__DeleteFileSetResponse *const*)ptr, "ns1:DeleteFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSet:
		return soap_out_PointerTo_ns1__DeleteFileSet(soap, tag, id, (_ns1__DeleteFileSet *const*)ptr, "ns1:DeleteFileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSetResponse:
		return soap_out_PointerTo_ns1__QureyFileSetResponse(soap, tag, id, (_ns1__QureyFileSetResponse *const*)ptr, "ns1:QureyFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSet:
		return soap_out_PointerTo_ns1__QureyFileSet(soap, tag, id, (_ns1__QureyFileSet *const*)ptr, "ns1:QureyFileSet");
	case SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSetResponse:
		return soap_out_PointerTo_ns1__CreateFileSetResponse(soap, tag, id, (_ns1__CreateFileSetResponse *const*)ptr, "ns1:CreateFileSetResponse");
	case SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSet:
		return soap_out_PointerTo_ns1__CreateFileSet(soap, tag, id, (_ns1__CreateFileSet *const*)ptr, "ns1:CreateFileSet");
	case SOAP_TYPE_FSM_PointerTons1__FileSet:
		return soap_out_PointerTons1__FileSet(soap, tag, id, (ns1__FileSet *const*)ptr, "ns1:FileSet");
	case SOAP_TYPE_FSM_PointerTons1__File:
		return soap_out_PointerTons1__File(soap, tag, id, (ns1__File *const*)ptr, "ns1:File");
	case SOAP_TYPE_FSM_PointerTons1__ArrayOfFile:
		return soap_out_PointerTons1__ArrayOfFile(soap, tag, id, (ns1__ArrayOfFile *const*)ptr, "ns1:ArrayOfFile");
	case SOAP_TYPE_FSM_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_FSM__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_FSM_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_FSM_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_FSM__ns1__CommitErrorResponse:
		((_ns1__CommitErrorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CommitError:
		((_ns1__CommitError *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CommitFileResponse:
		((_ns1__CommitFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CommitFile:
		((_ns1__CommitFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__ProgressNotifyResponse:
		((_ns1__ProgressNotifyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__ProgressNotify:
		((_ns1__ProgressNotify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CommitFileSetResponse:
		((_ns1__CommitFileSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CommitFileSet:
		((_ns1__CommitFileSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__DeleteFileSetResponse:
		((_ns1__DeleteFileSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__DeleteFileSet:
		((_ns1__DeleteFileSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__QureyFileSetResponse:
		((_ns1__QureyFileSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__QureyFileSet:
		((_ns1__QureyFileSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CreateFileSetResponse:
		((_ns1__CreateFileSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM__ns1__CreateFileSet:
		((_ns1__CreateFileSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM_ns1__File:
		((ns1__File *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM_ns1__ArrayOfFile:
		((ns1__ArrayOfFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM_ns1__FileSet:
		((ns1__FileSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FSM___ns3__CommitError:
		soap_serialize___ns3__CommitError(soap, (const struct __ns3__CommitError *)ptr);
		break;
	case SOAP_TYPE_FSM___ns3__CommitFile:
		soap_serialize___ns3__CommitFile(soap, (const struct __ns3__CommitFile *)ptr);
		break;
	case SOAP_TYPE_FSM___ns3__ProgressNotify:
		soap_serialize___ns3__ProgressNotify(soap, (const struct __ns3__ProgressNotify *)ptr);
		break;
	case SOAP_TYPE_FSM___ns3__CommitFileSet:
		soap_serialize___ns3__CommitFileSet(soap, (const struct __ns3__CommitFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns3__DeleteFileSet:
		soap_serialize___ns3__DeleteFileSet(soap, (const struct __ns3__DeleteFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns3__QureyFileSet:
		soap_serialize___ns3__QureyFileSet(soap, (const struct __ns3__QureyFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns3__CreateFileSet:
		soap_serialize___ns3__CreateFileSet(soap, (const struct __ns3__CreateFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__CommitError:
		soap_serialize___ns2__CommitError(soap, (const struct __ns2__CommitError *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__CommitFile:
		soap_serialize___ns2__CommitFile(soap, (const struct __ns2__CommitFile *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__ProgressNotify:
		soap_serialize___ns2__ProgressNotify(soap, (const struct __ns2__ProgressNotify *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__CommitFileSet:
		soap_serialize___ns2__CommitFileSet(soap, (const struct __ns2__CommitFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__DeleteFileSet:
		soap_serialize___ns2__DeleteFileSet(soap, (const struct __ns2__DeleteFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__QureyFileSet:
		soap_serialize___ns2__QureyFileSet(soap, (const struct __ns2__QureyFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM___ns2__CreateFileSet:
		soap_serialize___ns2__CreateFileSet(soap, (const struct __ns2__CreateFileSet *)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitErrorResponse:
		soap_serialize_PointerTo_ns1__CommitErrorResponse(soap, (_ns1__CommitErrorResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitError:
		soap_serialize_PointerTo_ns1__CommitError(soap, (_ns1__CommitError *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileResponse:
		soap_serialize_PointerTo_ns1__CommitFileResponse(soap, (_ns1__CommitFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFile:
		soap_serialize_PointerTo_ns1__CommitFile(soap, (_ns1__CommitFile *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotifyResponse:
		soap_serialize_PointerTo_ns1__ProgressNotifyResponse(soap, (_ns1__ProgressNotifyResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotify:
		soap_serialize_PointerTo_ns1__ProgressNotify(soap, (_ns1__ProgressNotify *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSetResponse:
		soap_serialize_PointerTo_ns1__CommitFileSetResponse(soap, (_ns1__CommitFileSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSet:
		soap_serialize_PointerTo_ns1__CommitFileSet(soap, (_ns1__CommitFileSet *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSetResponse:
		soap_serialize_PointerTo_ns1__DeleteFileSetResponse(soap, (_ns1__DeleteFileSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSet:
		soap_serialize_PointerTo_ns1__DeleteFileSet(soap, (_ns1__DeleteFileSet *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSetResponse:
		soap_serialize_PointerTo_ns1__QureyFileSetResponse(soap, (_ns1__QureyFileSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSet:
		soap_serialize_PointerTo_ns1__QureyFileSet(soap, (_ns1__QureyFileSet *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSetResponse:
		soap_serialize_PointerTo_ns1__CreateFileSetResponse(soap, (_ns1__CreateFileSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSet:
		soap_serialize_PointerTo_ns1__CreateFileSet(soap, (_ns1__CreateFileSet *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTons1__FileSet:
		soap_serialize_PointerTons1__FileSet(soap, (ns1__FileSet *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTons1__File:
		soap_serialize_PointerTons1__File(soap, (ns1__File *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTons1__ArrayOfFile:
		soap_serialize_PointerTons1__ArrayOfFile(soap, (ns1__ArrayOfFile *const*)ptr);
		break;
	case SOAP_TYPE_FSM_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_FSM__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_FSM_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_FSM_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM_ns1__FileSet:
		return (void*)soap_instantiate_ns1__FileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM_ns1__ArrayOfFile:
		return (void*)soap_instantiate_ns1__ArrayOfFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM_ns1__File:
		return (void*)soap_instantiate_ns1__File(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CreateFileSet:
		return (void*)soap_instantiate__ns1__CreateFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CreateFileSetResponse:
		return (void*)soap_instantiate__ns1__CreateFileSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__QureyFileSet:
		return (void*)soap_instantiate__ns1__QureyFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__QureyFileSetResponse:
		return (void*)soap_instantiate__ns1__QureyFileSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__DeleteFileSet:
		return (void*)soap_instantiate__ns1__DeleteFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__DeleteFileSetResponse:
		return (void*)soap_instantiate__ns1__DeleteFileSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CommitFileSet:
		return (void*)soap_instantiate__ns1__CommitFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CommitFileSetResponse:
		return (void*)soap_instantiate__ns1__CommitFileSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__ProgressNotify:
		return (void*)soap_instantiate__ns1__ProgressNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__ProgressNotifyResponse:
		return (void*)soap_instantiate__ns1__ProgressNotifyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CommitFile:
		return (void*)soap_instantiate__ns1__CommitFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CommitFileResponse:
		return (void*)soap_instantiate__ns1__CommitFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CommitError:
		return (void*)soap_instantiate__ns1__CommitError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM__ns1__CommitErrorResponse:
		return (void*)soap_instantiate__ns1__CommitErrorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__CreateFileSet:
		return (void*)soap_instantiate___ns2__CreateFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__QureyFileSet:
		return (void*)soap_instantiate___ns2__QureyFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__DeleteFileSet:
		return (void*)soap_instantiate___ns2__DeleteFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__CommitFileSet:
		return (void*)soap_instantiate___ns2__CommitFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__ProgressNotify:
		return (void*)soap_instantiate___ns2__ProgressNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__CommitFile:
		return (void*)soap_instantiate___ns2__CommitFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns2__CommitError:
		return (void*)soap_instantiate___ns2__CommitError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__CreateFileSet:
		return (void*)soap_instantiate___ns3__CreateFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__QureyFileSet:
		return (void*)soap_instantiate___ns3__QureyFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__DeleteFileSet:
		return (void*)soap_instantiate___ns3__DeleteFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__CommitFileSet:
		return (void*)soap_instantiate___ns3__CommitFileSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__ProgressNotify:
		return (void*)soap_instantiate___ns3__ProgressNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__CommitFile:
		return (void*)soap_instantiate___ns3__CommitFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FSM___ns3__CommitError:
		return (void*)soap_instantiate___ns3__CommitError(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_FSM_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_FSM_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_FSM_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_FSM_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_FSM_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_FSM_std__vectorTemplateOfPointerTons1__File:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__File(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_FSM_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_FSM_ns1__FileSet:
		if (p->size < 0)
			delete (ns1__FileSet*)p->ptr;
		else
			delete[] (ns1__FileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM_ns1__ArrayOfFile:
		if (p->size < 0)
			delete (ns1__ArrayOfFile*)p->ptr;
		else
			delete[] (ns1__ArrayOfFile*)p->ptr;
		break;
	case SOAP_TYPE_FSM_ns1__File:
		if (p->size < 0)
			delete (ns1__File*)p->ptr;
		else
			delete[] (ns1__File*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CreateFileSet:
		if (p->size < 0)
			delete (_ns1__CreateFileSet*)p->ptr;
		else
			delete[] (_ns1__CreateFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CreateFileSetResponse:
		if (p->size < 0)
			delete (_ns1__CreateFileSetResponse*)p->ptr;
		else
			delete[] (_ns1__CreateFileSetResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__QureyFileSet:
		if (p->size < 0)
			delete (_ns1__QureyFileSet*)p->ptr;
		else
			delete[] (_ns1__QureyFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__QureyFileSetResponse:
		if (p->size < 0)
			delete (_ns1__QureyFileSetResponse*)p->ptr;
		else
			delete[] (_ns1__QureyFileSetResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__DeleteFileSet:
		if (p->size < 0)
			delete (_ns1__DeleteFileSet*)p->ptr;
		else
			delete[] (_ns1__DeleteFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__DeleteFileSetResponse:
		if (p->size < 0)
			delete (_ns1__DeleteFileSetResponse*)p->ptr;
		else
			delete[] (_ns1__DeleteFileSetResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CommitFileSet:
		if (p->size < 0)
			delete (_ns1__CommitFileSet*)p->ptr;
		else
			delete[] (_ns1__CommitFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CommitFileSetResponse:
		if (p->size < 0)
			delete (_ns1__CommitFileSetResponse*)p->ptr;
		else
			delete[] (_ns1__CommitFileSetResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__ProgressNotify:
		if (p->size < 0)
			delete (_ns1__ProgressNotify*)p->ptr;
		else
			delete[] (_ns1__ProgressNotify*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__ProgressNotifyResponse:
		if (p->size < 0)
			delete (_ns1__ProgressNotifyResponse*)p->ptr;
		else
			delete[] (_ns1__ProgressNotifyResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CommitFile:
		if (p->size < 0)
			delete (_ns1__CommitFile*)p->ptr;
		else
			delete[] (_ns1__CommitFile*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CommitFileResponse:
		if (p->size < 0)
			delete (_ns1__CommitFileResponse*)p->ptr;
		else
			delete[] (_ns1__CommitFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CommitError:
		if (p->size < 0)
			delete (_ns1__CommitError*)p->ptr;
		else
			delete[] (_ns1__CommitError*)p->ptr;
		break;
	case SOAP_TYPE_FSM__ns1__CommitErrorResponse:
		if (p->size < 0)
			delete (_ns1__CommitErrorResponse*)p->ptr;
		else
			delete[] (_ns1__CommitErrorResponse*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__CreateFileSet:
		if (p->size < 0)
			delete (struct __ns2__CreateFileSet*)p->ptr;
		else
			delete[] (struct __ns2__CreateFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__QureyFileSet:
		if (p->size < 0)
			delete (struct __ns2__QureyFileSet*)p->ptr;
		else
			delete[] (struct __ns2__QureyFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__DeleteFileSet:
		if (p->size < 0)
			delete (struct __ns2__DeleteFileSet*)p->ptr;
		else
			delete[] (struct __ns2__DeleteFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__CommitFileSet:
		if (p->size < 0)
			delete (struct __ns2__CommitFileSet*)p->ptr;
		else
			delete[] (struct __ns2__CommitFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__ProgressNotify:
		if (p->size < 0)
			delete (struct __ns2__ProgressNotify*)p->ptr;
		else
			delete[] (struct __ns2__ProgressNotify*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__CommitFile:
		if (p->size < 0)
			delete (struct __ns2__CommitFile*)p->ptr;
		else
			delete[] (struct __ns2__CommitFile*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns2__CommitError:
		if (p->size < 0)
			delete (struct __ns2__CommitError*)p->ptr;
		else
			delete[] (struct __ns2__CommitError*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__CreateFileSet:
		if (p->size < 0)
			delete (struct __ns3__CreateFileSet*)p->ptr;
		else
			delete[] (struct __ns3__CreateFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__QureyFileSet:
		if (p->size < 0)
			delete (struct __ns3__QureyFileSet*)p->ptr;
		else
			delete[] (struct __ns3__QureyFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__DeleteFileSet:
		if (p->size < 0)
			delete (struct __ns3__DeleteFileSet*)p->ptr;
		else
			delete[] (struct __ns3__DeleteFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__CommitFileSet:
		if (p->size < 0)
			delete (struct __ns3__CommitFileSet*)p->ptr;
		else
			delete[] (struct __ns3__CommitFileSet*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__ProgressNotify:
		if (p->size < 0)
			delete (struct __ns3__ProgressNotify*)p->ptr;
		else
			delete[] (struct __ns3__ProgressNotify*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__CommitFile:
		if (p->size < 0)
			delete (struct __ns3__CommitFile*)p->ptr;
		else
			delete[] (struct __ns3__CommitFile*)p->ptr;
		break;
	case SOAP_TYPE_FSM___ns3__CommitError:
		if (p->size < 0)
			delete (struct __ns3__CommitError*)p->ptr;
		else
			delete[] (struct __ns3__CommitError*)p->ptr;
		break;
	case SOAP_TYPE_FSM_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_FSM_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_FSM_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_FSM_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_FSM_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_FSM_std__vectorTemplateOfPointerTons1__File:
		if (p->size < 0)
			delete (std::vector<ns1__File * >*)p->ptr;
		else
			delete[] (std::vector<ns1__File * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_FSM_std__vectorTemplateOfPointerTons1__File:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__File * >*)p)[len] = *(ns1__File **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_FSM_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_FSM_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_FSM_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_FSM_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_FSM_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_FSM_LONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_FSM_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_FSM_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_FSM_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_FSM_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new (std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns1__CommitErrorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__CommitErrorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CommitErrorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CommitErrorResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CommitErrorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CommitErrorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CommitErrorResponse(struct soap *soap, const char *tag, int id, const _ns1__CommitErrorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CommitErrorResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CommitErrorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CommitErrorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CommitErrorResponse * SOAP_FMAC4 soap_get__ns1__CommitErrorResponse(struct soap *soap, _ns1__CommitErrorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CommitErrorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CommitErrorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CommitErrorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CommitErrorResponse * SOAP_FMAC4 soap_in__ns1__CommitErrorResponse(struct soap *soap, const char *tag, _ns1__CommitErrorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CommitErrorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CommitErrorResponse, sizeof(_ns1__CommitErrorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CommitErrorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CommitErrorResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CommitErrorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CommitErrorResponse, 0, sizeof(_ns1__CommitErrorResponse), 0, soap_copy__ns1__CommitErrorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CommitErrorResponse * SOAP_FMAC4 soap_instantiate__ns1__CommitErrorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CommitErrorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CommitErrorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CommitErrorResponse);
		if (size)
			*size = sizeof(_ns1__CommitErrorResponse);
		((_ns1__CommitErrorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CommitErrorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CommitErrorResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CommitErrorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CommitErrorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CommitErrorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CommitErrorResponse %p -> %p\n", q, p));
	*(_ns1__CommitErrorResponse*)p = *(_ns1__CommitErrorResponse*)q;
}

void _ns1__CommitError::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CommitError::msg = NULL;
	/* transient soap skipped */
}

void _ns1__CommitError::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CommitError::msg);
	/* transient soap skipped */
}

int _ns1__CommitError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CommitError);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CommitError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CommitError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CommitError(struct soap *soap, const char *tag, int id, const _ns1__CommitError *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CommitError), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:msg", -1, &(a->_ns1__CommitError::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CommitError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CommitError(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CommitError * SOAP_FMAC4 soap_get__ns1__CommitError(struct soap *soap, _ns1__CommitError *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CommitError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CommitError::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CommitError(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CommitError * SOAP_FMAC4 soap_in__ns1__CommitError(struct soap *soap, const char *tag, _ns1__CommitError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CommitError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CommitError, sizeof(_ns1__CommitError), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CommitError)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CommitError *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:msg", &(a->_ns1__CommitError::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CommitError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CommitError, 0, sizeof(_ns1__CommitError), 0, soap_copy__ns1__CommitError);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CommitError * SOAP_FMAC4 soap_instantiate__ns1__CommitError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CommitError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CommitError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CommitError);
		if (size)
			*size = sizeof(_ns1__CommitError);
		((_ns1__CommitError*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CommitError[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CommitError);
		for (int i = 0; i < n; i++)
			((_ns1__CommitError*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CommitError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CommitError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CommitError %p -> %p\n", q, p));
	*(_ns1__CommitError*)p = *(_ns1__CommitError*)q;
}

void _ns1__CommitFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__CommitFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CommitFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CommitFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CommitFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CommitFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CommitFileResponse(struct soap *soap, const char *tag, int id, const _ns1__CommitFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CommitFileResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CommitFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CommitFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CommitFileResponse * SOAP_FMAC4 soap_get__ns1__CommitFileResponse(struct soap *soap, _ns1__CommitFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CommitFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CommitFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CommitFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CommitFileResponse * SOAP_FMAC4 soap_in__ns1__CommitFileResponse(struct soap *soap, const char *tag, _ns1__CommitFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CommitFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CommitFileResponse, sizeof(_ns1__CommitFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CommitFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CommitFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CommitFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CommitFileResponse, 0, sizeof(_ns1__CommitFileResponse), 0, soap_copy__ns1__CommitFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CommitFileResponse * SOAP_FMAC4 soap_instantiate__ns1__CommitFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CommitFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CommitFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CommitFileResponse);
		if (size)
			*size = sizeof(_ns1__CommitFileResponse);
		((_ns1__CommitFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CommitFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CommitFileResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CommitFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CommitFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CommitFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CommitFileResponse %p -> %p\n", q, p));
	*(_ns1__CommitFileResponse*)p = *(_ns1__CommitFileResponse*)q;
}

void _ns1__CommitFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__CommitFile::fsid);
	soap_default_LONG64(soap, &this->_ns1__CommitFile::fid);
	/* transient soap skipped */
}

void _ns1__CommitFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CommitFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CommitFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CommitFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CommitFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CommitFile(struct soap *soap, const char *tag, int id, const _ns1__CommitFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CommitFile), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:fsid", -1, &(a->_ns1__CommitFile::fsid), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:fid", -1, &(a->_ns1__CommitFile::fid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CommitFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CommitFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CommitFile * SOAP_FMAC4 soap_get__ns1__CommitFile(struct soap *soap, _ns1__CommitFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CommitFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CommitFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CommitFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CommitFile * SOAP_FMAC4 soap_in__ns1__CommitFile(struct soap *soap, const char *tag, _ns1__CommitFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CommitFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CommitFile, sizeof(_ns1__CommitFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CommitFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CommitFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_fsid1 = 1;
	size_t soap_flag_fid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fsid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:fsid", &(a->_ns1__CommitFile::fsid), "xsd:long"))
				{	soap_flag_fsid1--;
					continue;
				}
			if (soap_flag_fid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:fid", &(a->_ns1__CommitFile::fid), "xsd:long"))
				{	soap_flag_fid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CommitFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CommitFile, 0, sizeof(_ns1__CommitFile), 0, soap_copy__ns1__CommitFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fsid1 > 0 || soap_flag_fid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CommitFile * SOAP_FMAC4 soap_instantiate__ns1__CommitFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CommitFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CommitFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CommitFile);
		if (size)
			*size = sizeof(_ns1__CommitFile);
		((_ns1__CommitFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CommitFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CommitFile);
		for (int i = 0; i < n; i++)
			((_ns1__CommitFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CommitFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CommitFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CommitFile %p -> %p\n", q, p));
	*(_ns1__CommitFile*)p = *(_ns1__CommitFile*)q;
}

void _ns1__ProgressNotifyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ProgressNotifyResponse::ProgressNotifyResult);
	/* transient soap skipped */
}

void _ns1__ProgressNotifyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__ProgressNotifyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ProgressNotifyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ProgressNotifyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ProgressNotifyResponse(struct soap *soap, const char *tag, int id, const _ns1__ProgressNotifyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:ProgressNotifyResult");
	if (soap_out_int(soap, "ns1:ProgressNotifyResult", -1, &(a->_ns1__ProgressNotifyResponse::ProgressNotifyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ProgressNotifyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ProgressNotifyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ProgressNotifyResponse * SOAP_FMAC4 soap_get__ns1__ProgressNotifyResponse(struct soap *soap, _ns1__ProgressNotifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ProgressNotifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ProgressNotifyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ProgressNotifyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ProgressNotifyResponse * SOAP_FMAC4 soap_in__ns1__ProgressNotifyResponse(struct soap *soap, const char *tag, _ns1__ProgressNotifyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ProgressNotifyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse, sizeof(_ns1__ProgressNotifyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__ProgressNotifyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ProgressNotifyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ProgressNotifyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProgressNotifyResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ProgressNotifyResult", &(a->_ns1__ProgressNotifyResponse::ProgressNotifyResult), "xsd:int"))
				{	soap_flag_ProgressNotifyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:ProgressNotifyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ProgressNotifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse, 0, sizeof(_ns1__ProgressNotifyResponse), 0, soap_copy__ns1__ProgressNotifyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProgressNotifyResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ProgressNotifyResponse * SOAP_FMAC4 soap_instantiate__ns1__ProgressNotifyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ProgressNotifyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__ProgressNotifyResponse);
		if (size)
			*size = sizeof(_ns1__ProgressNotifyResponse);
		((_ns1__ProgressNotifyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__ProgressNotifyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ProgressNotifyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__ProgressNotifyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ProgressNotifyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ProgressNotifyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ProgressNotifyResponse %p -> %p\n", q, p));
	*(_ns1__ProgressNotifyResponse*)p = *(_ns1__ProgressNotifyResponse*)q;
}

void _ns1__ProgressNotify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__ProgressNotify::id);
	soap_default_LONG64(soap, &this->_ns1__ProgressNotify::total);
	soap_default_LONG64(soap, &this->_ns1__ProgressNotify::downloaded);
	/* transient soap skipped */
}

void _ns1__ProgressNotify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__ProgressNotify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__ProgressNotify);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ProgressNotify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ProgressNotify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ProgressNotify(struct soap *soap, const char *tag, int id, const _ns1__ProgressNotify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__ProgressNotify), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:id", -1, &(a->_ns1__ProgressNotify::id), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:total", -1, &(a->_ns1__ProgressNotify::total), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:downloaded", -1, &(a->_ns1__ProgressNotify::downloaded), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ProgressNotify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ProgressNotify(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ProgressNotify * SOAP_FMAC4 soap_get__ns1__ProgressNotify(struct soap *soap, _ns1__ProgressNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ProgressNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ProgressNotify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ProgressNotify(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ProgressNotify * SOAP_FMAC4 soap_in__ns1__ProgressNotify(struct soap *soap, const char *tag, _ns1__ProgressNotify *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ProgressNotify *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__ProgressNotify, sizeof(_ns1__ProgressNotify), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__ProgressNotify)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ProgressNotify *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_total1 = 1;
	size_t soap_flag_downloaded1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:id", &(a->_ns1__ProgressNotify::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:total", &(a->_ns1__ProgressNotify::total), "xsd:long"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_downloaded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:downloaded", &(a->_ns1__ProgressNotify::downloaded), "xsd:long"))
				{	soap_flag_downloaded1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ProgressNotify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__ProgressNotify, 0, sizeof(_ns1__ProgressNotify), 0, soap_copy__ns1__ProgressNotify);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_total1 > 0 || soap_flag_downloaded1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ProgressNotify * SOAP_FMAC4 soap_instantiate__ns1__ProgressNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ProgressNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__ProgressNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__ProgressNotify);
		if (size)
			*size = sizeof(_ns1__ProgressNotify);
		((_ns1__ProgressNotify*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__ProgressNotify[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ProgressNotify);
		for (int i = 0; i < n; i++)
			((_ns1__ProgressNotify*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ProgressNotify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ProgressNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ProgressNotify %p -> %p\n", q, p));
	*(_ns1__ProgressNotify*)p = *(_ns1__ProgressNotify*)q;
}

void _ns1__CommitFileSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__CommitFileSetResponse::CommitFileSetResult);
	/* transient soap skipped */
}

void _ns1__CommitFileSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CommitFileSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CommitFileSetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CommitFileSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CommitFileSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CommitFileSetResponse(struct soap *soap, const char *tag, int id, const _ns1__CommitFileSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CommitFileSetResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CommitFileSetResult");
	if (soap_out_int(soap, "ns1:CommitFileSetResult", -1, &(a->_ns1__CommitFileSetResponse::CommitFileSetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CommitFileSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CommitFileSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CommitFileSetResponse * SOAP_FMAC4 soap_get__ns1__CommitFileSetResponse(struct soap *soap, _ns1__CommitFileSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CommitFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CommitFileSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CommitFileSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CommitFileSetResponse * SOAP_FMAC4 soap_in__ns1__CommitFileSetResponse(struct soap *soap, const char *tag, _ns1__CommitFileSetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CommitFileSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CommitFileSetResponse, sizeof(_ns1__CommitFileSetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CommitFileSetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CommitFileSetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CommitFileSetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommitFileSetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:CommitFileSetResult", &(a->_ns1__CommitFileSetResponse::CommitFileSetResult), "xsd:int"))
				{	soap_flag_CommitFileSetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CommitFileSetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CommitFileSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CommitFileSetResponse, 0, sizeof(_ns1__CommitFileSetResponse), 0, soap_copy__ns1__CommitFileSetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CommitFileSetResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CommitFileSetResponse * SOAP_FMAC4 soap_instantiate__ns1__CommitFileSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CommitFileSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CommitFileSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CommitFileSetResponse);
		if (size)
			*size = sizeof(_ns1__CommitFileSetResponse);
		((_ns1__CommitFileSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CommitFileSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CommitFileSetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CommitFileSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CommitFileSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CommitFileSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CommitFileSetResponse %p -> %p\n", q, p));
	*(_ns1__CommitFileSetResponse*)p = *(_ns1__CommitFileSetResponse*)q;
}

void _ns1__CommitFileSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__CommitFileSet::id);
	/* transient soap skipped */
}

void _ns1__CommitFileSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CommitFileSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CommitFileSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CommitFileSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CommitFileSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CommitFileSet(struct soap *soap, const char *tag, int id, const _ns1__CommitFileSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CommitFileSet), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:id", -1, &(a->_ns1__CommitFileSet::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CommitFileSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CommitFileSet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CommitFileSet * SOAP_FMAC4 soap_get__ns1__CommitFileSet(struct soap *soap, _ns1__CommitFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CommitFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CommitFileSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CommitFileSet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CommitFileSet * SOAP_FMAC4 soap_in__ns1__CommitFileSet(struct soap *soap, const char *tag, _ns1__CommitFileSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CommitFileSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CommitFileSet, sizeof(_ns1__CommitFileSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CommitFileSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CommitFileSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:id", &(a->_ns1__CommitFileSet::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CommitFileSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CommitFileSet, 0, sizeof(_ns1__CommitFileSet), 0, soap_copy__ns1__CommitFileSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CommitFileSet * SOAP_FMAC4 soap_instantiate__ns1__CommitFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CommitFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CommitFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CommitFileSet);
		if (size)
			*size = sizeof(_ns1__CommitFileSet);
		((_ns1__CommitFileSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CommitFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CommitFileSet);
		for (int i = 0; i < n; i++)
			((_ns1__CommitFileSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CommitFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CommitFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CommitFileSet %p -> %p\n", q, p));
	*(_ns1__CommitFileSet*)p = *(_ns1__CommitFileSet*)q;
}

void _ns1__DeleteFileSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__DeleteFileSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__DeleteFileSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__DeleteFileSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteFileSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteFileSetResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteFileSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteFileSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteFileSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteFileSetResponse * SOAP_FMAC4 soap_get__ns1__DeleteFileSetResponse(struct soap *soap, _ns1__DeleteFileSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__DeleteFileSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteFileSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteFileSetResponse * SOAP_FMAC4 soap_in__ns1__DeleteFileSetResponse(struct soap *soap, const char *tag, _ns1__DeleteFileSetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteFileSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse, sizeof(_ns1__DeleteFileSetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__DeleteFileSetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteFileSetResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteFileSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse, 0, sizeof(_ns1__DeleteFileSetResponse), 0, soap_copy__ns1__DeleteFileSetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__DeleteFileSetResponse * SOAP_FMAC4 soap_instantiate__ns1__DeleteFileSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteFileSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__DeleteFileSetResponse);
		if (size)
			*size = sizeof(_ns1__DeleteFileSetResponse);
		((_ns1__DeleteFileSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__DeleteFileSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteFileSetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteFileSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteFileSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteFileSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteFileSetResponse %p -> %p\n", q, p));
	*(_ns1__DeleteFileSetResponse*)p = *(_ns1__DeleteFileSetResponse*)q;
}

void _ns1__DeleteFileSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__DeleteFileSet::id);
	/* transient soap skipped */
}

void _ns1__DeleteFileSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__DeleteFileSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__DeleteFileSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__DeleteFileSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteFileSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteFileSet(struct soap *soap, const char *tag, int id, const _ns1__DeleteFileSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__DeleteFileSet), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:id", -1, &(a->_ns1__DeleteFileSet::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteFileSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteFileSet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteFileSet * SOAP_FMAC4 soap_get__ns1__DeleteFileSet(struct soap *soap, _ns1__DeleteFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__DeleteFileSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteFileSet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteFileSet * SOAP_FMAC4 soap_in__ns1__DeleteFileSet(struct soap *soap, const char *tag, _ns1__DeleteFileSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteFileSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__DeleteFileSet, sizeof(_ns1__DeleteFileSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__DeleteFileSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteFileSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:id", &(a->_ns1__DeleteFileSet::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteFileSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__DeleteFileSet, 0, sizeof(_ns1__DeleteFileSet), 0, soap_copy__ns1__DeleteFileSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__DeleteFileSet * SOAP_FMAC4 soap_instantiate__ns1__DeleteFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__DeleteFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__DeleteFileSet);
		if (size)
			*size = sizeof(_ns1__DeleteFileSet);
		((_ns1__DeleteFileSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__DeleteFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteFileSet);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteFileSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteFileSet %p -> %p\n", q, p));
	*(_ns1__DeleteFileSet*)p = *(_ns1__DeleteFileSet*)q;
}

void _ns1__QureyFileSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QureyFileSetResponse::QureyFileSetResult = NULL;
	/* transient soap skipped */
}

void _ns1__QureyFileSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__FileSet(soap, &this->_ns1__QureyFileSetResponse::QureyFileSetResult);
	/* transient soap skipped */
}

int _ns1__QureyFileSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__QureyFileSetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__QureyFileSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QureyFileSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QureyFileSetResponse(struct soap *soap, const char *tag, int id, const _ns1__QureyFileSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__QureyFileSetResponse), type))
		return soap->error;
	if (a->QureyFileSetResult)
		soap_element_result(soap, "ns1:QureyFileSetResult");
	if (soap_out_PointerTons1__FileSet(soap, "ns1:QureyFileSetResult", -1, &(a->_ns1__QureyFileSetResponse::QureyFileSetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__QureyFileSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QureyFileSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QureyFileSetResponse * SOAP_FMAC4 soap_get__ns1__QureyFileSetResponse(struct soap *soap, _ns1__QureyFileSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QureyFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__QureyFileSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QureyFileSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QureyFileSetResponse * SOAP_FMAC4 soap_in__ns1__QureyFileSetResponse(struct soap *soap, const char *tag, _ns1__QureyFileSetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QureyFileSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__QureyFileSetResponse, sizeof(_ns1__QureyFileSetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__QureyFileSetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__QureyFileSetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_QureyFileSetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QureyFileSetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FileSet(soap, "ns1:QureyFileSetResult", &(a->_ns1__QureyFileSetResponse::QureyFileSetResult), "ns1:FileSet"))
				{	soap_flag_QureyFileSetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:QureyFileSetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QureyFileSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__QureyFileSetResponse, 0, sizeof(_ns1__QureyFileSetResponse), 0, soap_copy__ns1__QureyFileSetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__QureyFileSetResponse * SOAP_FMAC4 soap_instantiate__ns1__QureyFileSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QureyFileSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__QureyFileSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__QureyFileSetResponse);
		if (size)
			*size = sizeof(_ns1__QureyFileSetResponse);
		((_ns1__QureyFileSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__QureyFileSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__QureyFileSetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__QureyFileSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__QureyFileSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__QureyFileSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__QureyFileSetResponse %p -> %p\n", q, p));
	*(_ns1__QureyFileSetResponse*)p = *(_ns1__QureyFileSetResponse*)q;
}

void _ns1__QureyFileSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__QureyFileSet::id);
	/* transient soap skipped */
}

void _ns1__QureyFileSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__QureyFileSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__QureyFileSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__QureyFileSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QureyFileSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QureyFileSet(struct soap *soap, const char *tag, int id, const _ns1__QureyFileSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__QureyFileSet), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:id", -1, &(a->_ns1__QureyFileSet::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__QureyFileSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QureyFileSet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QureyFileSet * SOAP_FMAC4 soap_get__ns1__QureyFileSet(struct soap *soap, _ns1__QureyFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QureyFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__QureyFileSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QureyFileSet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QureyFileSet * SOAP_FMAC4 soap_in__ns1__QureyFileSet(struct soap *soap, const char *tag, _ns1__QureyFileSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QureyFileSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__QureyFileSet, sizeof(_ns1__QureyFileSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__QureyFileSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__QureyFileSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:id", &(a->_ns1__QureyFileSet::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QureyFileSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__QureyFileSet, 0, sizeof(_ns1__QureyFileSet), 0, soap_copy__ns1__QureyFileSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__QureyFileSet * SOAP_FMAC4 soap_instantiate__ns1__QureyFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QureyFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__QureyFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__QureyFileSet);
		if (size)
			*size = sizeof(_ns1__QureyFileSet);
		((_ns1__QureyFileSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__QureyFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__QureyFileSet);
		for (int i = 0; i < n; i++)
			((_ns1__QureyFileSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__QureyFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__QureyFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__QureyFileSet %p -> %p\n", q, p));
	*(_ns1__QureyFileSet*)p = *(_ns1__QureyFileSet*)q;
}

void _ns1__CreateFileSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__CreateFileSetResponse::CreateFileSetResult);
	/* transient soap skipped */
}

void _ns1__CreateFileSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CreateFileSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CreateFileSetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CreateFileSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateFileSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateFileSetResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateFileSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CreateFileSetResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CreateFileSetResult");
	if (soap_out_LONG64(soap, "ns1:CreateFileSetResult", -1, &(a->_ns1__CreateFileSetResponse::CreateFileSetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateFileSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateFileSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateFileSetResponse * SOAP_FMAC4 soap_get__ns1__CreateFileSetResponse(struct soap *soap, _ns1__CreateFileSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CreateFileSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateFileSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateFileSetResponse * SOAP_FMAC4 soap_in__ns1__CreateFileSetResponse(struct soap *soap, const char *tag, _ns1__CreateFileSetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateFileSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CreateFileSetResponse, sizeof(_ns1__CreateFileSetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CreateFileSetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CreateFileSetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CreateFileSetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CreateFileSetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:CreateFileSetResult", &(a->_ns1__CreateFileSetResponse::CreateFileSetResult), "xsd:long"))
				{	soap_flag_CreateFileSetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CreateFileSetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CreateFileSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CreateFileSetResponse, 0, sizeof(_ns1__CreateFileSetResponse), 0, soap_copy__ns1__CreateFileSetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CreateFileSetResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CreateFileSetResponse * SOAP_FMAC4 soap_instantiate__ns1__CreateFileSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateFileSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CreateFileSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CreateFileSetResponse);
		if (size)
			*size = sizeof(_ns1__CreateFileSetResponse);
		((_ns1__CreateFileSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CreateFileSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CreateFileSetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CreateFileSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CreateFileSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CreateFileSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CreateFileSetResponse %p -> %p\n", q, p));
	*(_ns1__CreateFileSetResponse*)p = *(_ns1__CreateFileSetResponse*)q;
}

void _ns1__CreateFileSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CreateFileSet::fset = NULL;
	/* transient soap skipped */
}

void _ns1__CreateFileSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__FileSet(soap, &this->_ns1__CreateFileSet::fset);
	/* transient soap skipped */
}

int _ns1__CreateFileSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM__ns1__CreateFileSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__CreateFileSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateFileSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateFileSet(struct soap *soap, const char *tag, int id, const _ns1__CreateFileSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM__ns1__CreateFileSet), type))
		return soap->error;
	if (soap_out_PointerTons1__FileSet(soap, "ns1:fset", -1, &(a->_ns1__CreateFileSet::fset), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateFileSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateFileSet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateFileSet * SOAP_FMAC4 soap_get__ns1__CreateFileSet(struct soap *soap, _ns1__CreateFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__CreateFileSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateFileSet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateFileSet * SOAP_FMAC4 soap_in__ns1__CreateFileSet(struct soap *soap, const char *tag, _ns1__CreateFileSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateFileSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM__ns1__CreateFileSet, sizeof(_ns1__CreateFileSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM__ns1__CreateFileSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CreateFileSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_fset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FileSet(soap, "ns1:fset", &(a->_ns1__CreateFileSet::fset), "ns1:FileSet"))
				{	soap_flag_fset1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CreateFileSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM__ns1__CreateFileSet, 0, sizeof(_ns1__CreateFileSet), 0, soap_copy__ns1__CreateFileSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__CreateFileSet * SOAP_FMAC4 soap_instantiate__ns1__CreateFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM__ns1__CreateFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__CreateFileSet);
		if (size)
			*size = sizeof(_ns1__CreateFileSet);
		((_ns1__CreateFileSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__CreateFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CreateFileSet);
		for (int i = 0; i < n; i++)
			((_ns1__CreateFileSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CreateFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CreateFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CreateFileSet %p -> %p\n", q, p));
	*(_ns1__CreateFileSet*)p = *(_ns1__CreateFileSet*)q;
}

void ns1__File::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->ns1__File::ID);
	soap_default_LONG64(soap, &this->ns1__File::FileSetID);
	this->ns1__File::FileName = NULL;
	soap_default_LONG64(soap, &this->ns1__File::Size);
	soap_default_int(soap, &this->ns1__File::ShowIndex);
	/* transient soap skipped */
}

void ns1__File::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__File::FileName);
	/* transient soap skipped */
}

int ns1__File::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM_ns1__File);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__File::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__File(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__File(struct soap *soap, const char *tag, int id, const ns1__File *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_ns1__File), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:ID", -1, &(a->ns1__File::ID), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:FileSetID", -1, &(a->ns1__File::FileSetID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:FileName", -1, &(a->ns1__File::FileName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:Size", -1, &(a->ns1__File::Size), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ShowIndex", -1, &(a->ns1__File::ShowIndex), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__File::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__File(soap, this, tag, type);
}

SOAP_FMAC3 ns1__File * SOAP_FMAC4 soap_get_ns1__File(struct soap *soap, ns1__File *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__File(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__File::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__File(soap, tag, this, type);
}

SOAP_FMAC3 ns1__File * SOAP_FMAC4 soap_in_ns1__File(struct soap *soap, const char *tag, ns1__File *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__File *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_ns1__File, sizeof(ns1__File), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM_ns1__File)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__File *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_FileSetID1 = 1;
	size_t soap_flag_FileName1 = 1;
	size_t soap_flag_Size1 = 1;
	size_t soap_flag_ShowIndex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:ID", &(a->ns1__File::ID), "xsd:long"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_FileSetID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:FileSetID", &(a->ns1__File::FileSetID), "xsd:long"))
				{	soap_flag_FileSetID1--;
					continue;
				}
			if (soap_flag_FileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:FileName", &(a->ns1__File::FileName), "xsd:string"))
				{	soap_flag_FileName1--;
					continue;
				}
			if (soap_flag_Size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:Size", &(a->ns1__File::Size), "xsd:long"))
				{	soap_flag_Size1--;
					continue;
				}
			if (soap_flag_ShowIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ShowIndex", &(a->ns1__File::ShowIndex), "xsd:int"))
				{	soap_flag_ShowIndex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__File *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_ns1__File, 0, sizeof(ns1__File), 0, soap_copy_ns1__File);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_FileSetID1 > 0 || soap_flag_Size1 > 0 || soap_flag_ShowIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__File * SOAP_FMAC4 soap_instantiate_ns1__File(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__File(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_ns1__File, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (ns1__File);
		if (size)
			*size = sizeof(ns1__File);
		((ns1__File*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (ns1__File[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__File);
		for (int i = 0; i < n; i++)
			((ns1__File*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__File*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__File(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__File %p -> %p\n", q, p));
	*(ns1__File*)p = *(ns1__File*)q;
}

void ns1__ArrayOfFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__File(soap, &this->ns1__ArrayOfFile::File);
	/* transient soap skipped */
}

void ns1__ArrayOfFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__File(soap, &this->ns1__ArrayOfFile::File);
	/* transient soap skipped */
}

int ns1__ArrayOfFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM_ns1__ArrayOfFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfFile(struct soap *soap, const char *tag, int id, const ns1__ArrayOfFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_ns1__ArrayOfFile), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__File(soap, "ns1:File", -1, &(a->ns1__ArrayOfFile::File), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfFile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfFile * SOAP_FMAC4 soap_get_ns1__ArrayOfFile(struct soap *soap, ns1__ArrayOfFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfFile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfFile * SOAP_FMAC4 soap_in_ns1__ArrayOfFile(struct soap *soap, const char *tag, ns1__ArrayOfFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_ns1__ArrayOfFile, sizeof(ns1__ArrayOfFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM_ns1__ArrayOfFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfFile *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__File(soap, "ns1:File", &(a->ns1__ArrayOfFile::File), "ns1:File"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_ns1__ArrayOfFile, 0, sizeof(ns1__ArrayOfFile), 0, soap_copy_ns1__ArrayOfFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfFile * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_ns1__ArrayOfFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (ns1__ArrayOfFile);
		if (size)
			*size = sizeof(ns1__ArrayOfFile);
		((ns1__ArrayOfFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (ns1__ArrayOfFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfFile);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfFile %p -> %p\n", q, p));
	*(ns1__ArrayOfFile*)p = *(ns1__ArrayOfFile*)q;
}

void ns1__FileSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->ns1__FileSet::ID);
	this->ns1__FileSet::Path = NULL;
	soap_default_bool(soap, &this->ns1__FileSet::Ready);
	this->ns1__FileSet::File = NULL;
	/* transient soap skipped */
}

void ns1__FileSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__FileSet::Path);
	soap_serialize_PointerTons1__ArrayOfFile(soap, &this->ns1__FileSet::File);
	/* transient soap skipped */
}

int ns1__FileSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_FSM_ns1__FileSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__FileSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FileSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FileSet(struct soap *soap, const char *tag, int id, const ns1__FileSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_ns1__FileSet), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:ID", -1, &(a->ns1__FileSet::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Path", -1, &(a->ns1__FileSet::Path), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:Ready", -1, &(a->ns1__FileSet::Ready), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfFile(soap, "ns1:File", -1, &(a->ns1__FileSet::File), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__FileSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FileSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FileSet * SOAP_FMAC4 soap_get_ns1__FileSet(struct soap *soap, ns1__FileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__FileSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FileSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FileSet * SOAP_FMAC4 soap_in_ns1__FileSet(struct soap *soap, const char *tag, ns1__FileSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FileSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_ns1__FileSet, sizeof(ns1__FileSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_FSM_ns1__FileSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__FileSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Path1 = 1;
	size_t soap_flag_Ready1 = 1;
	size_t soap_flag_File1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:ID", &(a->ns1__FileSet::ID), "xsd:long"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Path", &(a->ns1__FileSet::Path), "xsd:string"))
				{	soap_flag_Path1--;
					continue;
				}
			if (soap_flag_Ready1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:Ready", &(a->ns1__FileSet::Ready), "xsd:boolean"))
				{	soap_flag_Ready1--;
					continue;
				}
			if (soap_flag_File1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfFile(soap, "ns1:File", &(a->ns1__FileSet::File), "ns1:ArrayOfFile"))
				{	soap_flag_File1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FileSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_ns1__FileSet, 0, sizeof(ns1__FileSet), 0, soap_copy_ns1__FileSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Ready1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__FileSet * SOAP_FMAC4 soap_instantiate_ns1__FileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_ns1__FileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (ns1__FileSet);
		if (size)
			*size = sizeof(ns1__FileSet);
		((ns1__FileSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (ns1__FileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__FileSet);
		for (int i = 0; i < n; i++)
			((ns1__FileSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__FileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__FileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__FileSet %p -> %p\n", q, p));
	*(ns1__FileSet*)p = *(ns1__FileSet*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FSM_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FSM_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FSM_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__CommitError(struct soap *soap, struct __ns3__CommitError *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CommitError = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__CommitError(struct soap *soap, const struct __ns3__CommitError *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CommitError(soap, &a->ns1__CommitError);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__CommitError(struct soap *soap, const struct __ns3__CommitError *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__CommitError(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__CommitError(struct soap *soap, const char *tag, int id, const struct __ns3__CommitError *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CommitError(soap, "ns1:CommitError", -1, &a->ns1__CommitError, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__CommitError * SOAP_FMAC4 soap_get___ns3__CommitError(struct soap *soap, struct __ns3__CommitError *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__CommitError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__CommitError * SOAP_FMAC4 soap_in___ns3__CommitError(struct soap *soap, const char *tag, struct __ns3__CommitError *a, const char *type)
{
	size_t soap_flag_ns1__CommitError = 1;
	short soap_flag;
	a = (struct __ns3__CommitError *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__CommitError, sizeof(struct __ns3__CommitError), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__CommitError(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CommitError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CommitError(soap, "ns1:CommitError", &a->ns1__CommitError, ""))
				{	soap_flag_ns1__CommitError--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__CommitError * SOAP_FMAC4 soap_instantiate___ns3__CommitError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__CommitError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__CommitError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__CommitError);
		if (size)
			*size = sizeof(struct __ns3__CommitError);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__CommitError[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__CommitError);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__CommitError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__CommitError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__CommitError %p -> %p\n", q, p));
	*(struct __ns3__CommitError*)p = *(struct __ns3__CommitError*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__CommitFile(struct soap *soap, struct __ns3__CommitFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CommitFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__CommitFile(struct soap *soap, const struct __ns3__CommitFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CommitFile(soap, &a->ns1__CommitFile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__CommitFile(struct soap *soap, const struct __ns3__CommitFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__CommitFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__CommitFile(struct soap *soap, const char *tag, int id, const struct __ns3__CommitFile *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CommitFile(soap, "ns1:CommitFile", -1, &a->ns1__CommitFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__CommitFile * SOAP_FMAC4 soap_get___ns3__CommitFile(struct soap *soap, struct __ns3__CommitFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__CommitFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__CommitFile * SOAP_FMAC4 soap_in___ns3__CommitFile(struct soap *soap, const char *tag, struct __ns3__CommitFile *a, const char *type)
{
	size_t soap_flag_ns1__CommitFile = 1;
	short soap_flag;
	a = (struct __ns3__CommitFile *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__CommitFile, sizeof(struct __ns3__CommitFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__CommitFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CommitFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CommitFile(soap, "ns1:CommitFile", &a->ns1__CommitFile, ""))
				{	soap_flag_ns1__CommitFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__CommitFile * SOAP_FMAC4 soap_instantiate___ns3__CommitFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__CommitFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__CommitFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__CommitFile);
		if (size)
			*size = sizeof(struct __ns3__CommitFile);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__CommitFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__CommitFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__CommitFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__CommitFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__CommitFile %p -> %p\n", q, p));
	*(struct __ns3__CommitFile*)p = *(struct __ns3__CommitFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__ProgressNotify(struct soap *soap, struct __ns3__ProgressNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ProgressNotify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__ProgressNotify(struct soap *soap, const struct __ns3__ProgressNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ProgressNotify(soap, &a->ns1__ProgressNotify);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__ProgressNotify(struct soap *soap, const struct __ns3__ProgressNotify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__ProgressNotify(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__ProgressNotify(struct soap *soap, const char *tag, int id, const struct __ns3__ProgressNotify *a, const char *type)
{
	if (soap_out_PointerTo_ns1__ProgressNotify(soap, "ns1:ProgressNotify", -1, &a->ns1__ProgressNotify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__ProgressNotify * SOAP_FMAC4 soap_get___ns3__ProgressNotify(struct soap *soap, struct __ns3__ProgressNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__ProgressNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__ProgressNotify * SOAP_FMAC4 soap_in___ns3__ProgressNotify(struct soap *soap, const char *tag, struct __ns3__ProgressNotify *a, const char *type)
{
	size_t soap_flag_ns1__ProgressNotify = 1;
	short soap_flag;
	a = (struct __ns3__ProgressNotify *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__ProgressNotify, sizeof(struct __ns3__ProgressNotify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__ProgressNotify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ProgressNotify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ProgressNotify(soap, "ns1:ProgressNotify", &a->ns1__ProgressNotify, ""))
				{	soap_flag_ns1__ProgressNotify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__ProgressNotify * SOAP_FMAC4 soap_instantiate___ns3__ProgressNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__ProgressNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__ProgressNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__ProgressNotify);
		if (size)
			*size = sizeof(struct __ns3__ProgressNotify);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__ProgressNotify[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__ProgressNotify);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__ProgressNotify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__ProgressNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__ProgressNotify %p -> %p\n", q, p));
	*(struct __ns3__ProgressNotify*)p = *(struct __ns3__ProgressNotify*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__CommitFileSet(struct soap *soap, struct __ns3__CommitFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CommitFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__CommitFileSet(struct soap *soap, const struct __ns3__CommitFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CommitFileSet(soap, &a->ns1__CommitFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__CommitFileSet(struct soap *soap, const struct __ns3__CommitFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__CommitFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__CommitFileSet(struct soap *soap, const char *tag, int id, const struct __ns3__CommitFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CommitFileSet(soap, "ns1:CommitFileSet", -1, &a->ns1__CommitFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__CommitFileSet * SOAP_FMAC4 soap_get___ns3__CommitFileSet(struct soap *soap, struct __ns3__CommitFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__CommitFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__CommitFileSet * SOAP_FMAC4 soap_in___ns3__CommitFileSet(struct soap *soap, const char *tag, struct __ns3__CommitFileSet *a, const char *type)
{
	size_t soap_flag_ns1__CommitFileSet = 1;
	short soap_flag;
	a = (struct __ns3__CommitFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__CommitFileSet, sizeof(struct __ns3__CommitFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__CommitFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CommitFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CommitFileSet(soap, "ns1:CommitFileSet", &a->ns1__CommitFileSet, ""))
				{	soap_flag_ns1__CommitFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__CommitFileSet * SOAP_FMAC4 soap_instantiate___ns3__CommitFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__CommitFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__CommitFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__CommitFileSet);
		if (size)
			*size = sizeof(struct __ns3__CommitFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__CommitFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__CommitFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__CommitFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__CommitFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__CommitFileSet %p -> %p\n", q, p));
	*(struct __ns3__CommitFileSet*)p = *(struct __ns3__CommitFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__DeleteFileSet(struct soap *soap, struct __ns3__DeleteFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__DeleteFileSet(struct soap *soap, const struct __ns3__DeleteFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteFileSet(soap, &a->ns1__DeleteFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__DeleteFileSet(struct soap *soap, const struct __ns3__DeleteFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__DeleteFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__DeleteFileSet(struct soap *soap, const char *tag, int id, const struct __ns3__DeleteFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteFileSet(soap, "ns1:DeleteFileSet", -1, &a->ns1__DeleteFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__DeleteFileSet * SOAP_FMAC4 soap_get___ns3__DeleteFileSet(struct soap *soap, struct __ns3__DeleteFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__DeleteFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__DeleteFileSet * SOAP_FMAC4 soap_in___ns3__DeleteFileSet(struct soap *soap, const char *tag, struct __ns3__DeleteFileSet *a, const char *type)
{
	size_t soap_flag_ns1__DeleteFileSet = 1;
	short soap_flag;
	a = (struct __ns3__DeleteFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__DeleteFileSet, sizeof(struct __ns3__DeleteFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__DeleteFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteFileSet(soap, "ns1:DeleteFileSet", &a->ns1__DeleteFileSet, ""))
				{	soap_flag_ns1__DeleteFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__DeleteFileSet * SOAP_FMAC4 soap_instantiate___ns3__DeleteFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__DeleteFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__DeleteFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__DeleteFileSet);
		if (size)
			*size = sizeof(struct __ns3__DeleteFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__DeleteFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__DeleteFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__DeleteFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__DeleteFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__DeleteFileSet %p -> %p\n", q, p));
	*(struct __ns3__DeleteFileSet*)p = *(struct __ns3__DeleteFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__QureyFileSet(struct soap *soap, struct __ns3__QureyFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QureyFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__QureyFileSet(struct soap *soap, const struct __ns3__QureyFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__QureyFileSet(soap, &a->ns1__QureyFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__QureyFileSet(struct soap *soap, const struct __ns3__QureyFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__QureyFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__QureyFileSet(struct soap *soap, const char *tag, int id, const struct __ns3__QureyFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__QureyFileSet(soap, "ns1:QureyFileSet", -1, &a->ns1__QureyFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__QureyFileSet * SOAP_FMAC4 soap_get___ns3__QureyFileSet(struct soap *soap, struct __ns3__QureyFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__QureyFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__QureyFileSet * SOAP_FMAC4 soap_in___ns3__QureyFileSet(struct soap *soap, const char *tag, struct __ns3__QureyFileSet *a, const char *type)
{
	size_t soap_flag_ns1__QureyFileSet = 1;
	short soap_flag;
	a = (struct __ns3__QureyFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__QureyFileSet, sizeof(struct __ns3__QureyFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__QureyFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QureyFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QureyFileSet(soap, "ns1:QureyFileSet", &a->ns1__QureyFileSet, ""))
				{	soap_flag_ns1__QureyFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__QureyFileSet * SOAP_FMAC4 soap_instantiate___ns3__QureyFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__QureyFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__QureyFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__QureyFileSet);
		if (size)
			*size = sizeof(struct __ns3__QureyFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__QureyFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__QureyFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__QureyFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__QureyFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__QureyFileSet %p -> %p\n", q, p));
	*(struct __ns3__QureyFileSet*)p = *(struct __ns3__QureyFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__CreateFileSet(struct soap *soap, struct __ns3__CreateFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__CreateFileSet(struct soap *soap, const struct __ns3__CreateFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CreateFileSet(soap, &a->ns1__CreateFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__CreateFileSet(struct soap *soap, const struct __ns3__CreateFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__CreateFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__CreateFileSet(struct soap *soap, const char *tag, int id, const struct __ns3__CreateFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateFileSet(soap, "ns1:CreateFileSet", -1, &a->ns1__CreateFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__CreateFileSet * SOAP_FMAC4 soap_get___ns3__CreateFileSet(struct soap *soap, struct __ns3__CreateFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__CreateFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__CreateFileSet * SOAP_FMAC4 soap_in___ns3__CreateFileSet(struct soap *soap, const char *tag, struct __ns3__CreateFileSet *a, const char *type)
{
	size_t soap_flag_ns1__CreateFileSet = 1;
	short soap_flag;
	a = (struct __ns3__CreateFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns3__CreateFileSet, sizeof(struct __ns3__CreateFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__CreateFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateFileSet(soap, "ns1:CreateFileSet", &a->ns1__CreateFileSet, ""))
				{	soap_flag_ns1__CreateFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__CreateFileSet * SOAP_FMAC4 soap_instantiate___ns3__CreateFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__CreateFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns3__CreateFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns3__CreateFileSet);
		if (size)
			*size = sizeof(struct __ns3__CreateFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns3__CreateFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__CreateFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__CreateFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__CreateFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__CreateFileSet %p -> %p\n", q, p));
	*(struct __ns3__CreateFileSet*)p = *(struct __ns3__CreateFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CommitError(struct soap *soap, struct __ns2__CommitError *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CommitError = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CommitError(struct soap *soap, const struct __ns2__CommitError *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CommitError(soap, &a->ns1__CommitError);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CommitError(struct soap *soap, const struct __ns2__CommitError *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CommitError(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CommitError(struct soap *soap, const char *tag, int id, const struct __ns2__CommitError *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CommitError(soap, "ns1:CommitError", -1, &a->ns1__CommitError, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CommitError * SOAP_FMAC4 soap_get___ns2__CommitError(struct soap *soap, struct __ns2__CommitError *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CommitError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__CommitError * SOAP_FMAC4 soap_in___ns2__CommitError(struct soap *soap, const char *tag, struct __ns2__CommitError *a, const char *type)
{
	size_t soap_flag_ns1__CommitError = 1;
	short soap_flag;
	a = (struct __ns2__CommitError *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__CommitError, sizeof(struct __ns2__CommitError), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CommitError(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CommitError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CommitError(soap, "ns1:CommitError", &a->ns1__CommitError, ""))
				{	soap_flag_ns1__CommitError--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__CommitError * SOAP_FMAC4 soap_instantiate___ns2__CommitError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CommitError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__CommitError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__CommitError);
		if (size)
			*size = sizeof(struct __ns2__CommitError);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__CommitError[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__CommitError);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__CommitError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CommitError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CommitError %p -> %p\n", q, p));
	*(struct __ns2__CommitError*)p = *(struct __ns2__CommitError*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CommitFile(struct soap *soap, struct __ns2__CommitFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CommitFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CommitFile(struct soap *soap, const struct __ns2__CommitFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CommitFile(soap, &a->ns1__CommitFile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CommitFile(struct soap *soap, const struct __ns2__CommitFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CommitFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CommitFile(struct soap *soap, const char *tag, int id, const struct __ns2__CommitFile *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CommitFile(soap, "ns1:CommitFile", -1, &a->ns1__CommitFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CommitFile * SOAP_FMAC4 soap_get___ns2__CommitFile(struct soap *soap, struct __ns2__CommitFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CommitFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__CommitFile * SOAP_FMAC4 soap_in___ns2__CommitFile(struct soap *soap, const char *tag, struct __ns2__CommitFile *a, const char *type)
{
	size_t soap_flag_ns1__CommitFile = 1;
	short soap_flag;
	a = (struct __ns2__CommitFile *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__CommitFile, sizeof(struct __ns2__CommitFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CommitFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CommitFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CommitFile(soap, "ns1:CommitFile", &a->ns1__CommitFile, ""))
				{	soap_flag_ns1__CommitFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__CommitFile * SOAP_FMAC4 soap_instantiate___ns2__CommitFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CommitFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__CommitFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__CommitFile);
		if (size)
			*size = sizeof(struct __ns2__CommitFile);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__CommitFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__CommitFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__CommitFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CommitFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CommitFile %p -> %p\n", q, p));
	*(struct __ns2__CommitFile*)p = *(struct __ns2__CommitFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__ProgressNotify(struct soap *soap, struct __ns2__ProgressNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ProgressNotify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__ProgressNotify(struct soap *soap, const struct __ns2__ProgressNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ProgressNotify(soap, &a->ns1__ProgressNotify);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__ProgressNotify(struct soap *soap, const struct __ns2__ProgressNotify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__ProgressNotify(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ProgressNotify(struct soap *soap, const char *tag, int id, const struct __ns2__ProgressNotify *a, const char *type)
{
	if (soap_out_PointerTo_ns1__ProgressNotify(soap, "ns1:ProgressNotify", -1, &a->ns1__ProgressNotify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ProgressNotify * SOAP_FMAC4 soap_get___ns2__ProgressNotify(struct soap *soap, struct __ns2__ProgressNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ProgressNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__ProgressNotify * SOAP_FMAC4 soap_in___ns2__ProgressNotify(struct soap *soap, const char *tag, struct __ns2__ProgressNotify *a, const char *type)
{
	size_t soap_flag_ns1__ProgressNotify = 1;
	short soap_flag;
	a = (struct __ns2__ProgressNotify *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__ProgressNotify, sizeof(struct __ns2__ProgressNotify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__ProgressNotify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ProgressNotify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ProgressNotify(soap, "ns1:ProgressNotify", &a->ns1__ProgressNotify, ""))
				{	soap_flag_ns1__ProgressNotify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__ProgressNotify * SOAP_FMAC4 soap_instantiate___ns2__ProgressNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ProgressNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__ProgressNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__ProgressNotify);
		if (size)
			*size = sizeof(struct __ns2__ProgressNotify);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__ProgressNotify[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__ProgressNotify);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__ProgressNotify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ProgressNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__ProgressNotify %p -> %p\n", q, p));
	*(struct __ns2__ProgressNotify*)p = *(struct __ns2__ProgressNotify*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CommitFileSet(struct soap *soap, struct __ns2__CommitFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CommitFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CommitFileSet(struct soap *soap, const struct __ns2__CommitFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CommitFileSet(soap, &a->ns1__CommitFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CommitFileSet(struct soap *soap, const struct __ns2__CommitFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CommitFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CommitFileSet(struct soap *soap, const char *tag, int id, const struct __ns2__CommitFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CommitFileSet(soap, "ns1:CommitFileSet", -1, &a->ns1__CommitFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CommitFileSet * SOAP_FMAC4 soap_get___ns2__CommitFileSet(struct soap *soap, struct __ns2__CommitFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CommitFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__CommitFileSet * SOAP_FMAC4 soap_in___ns2__CommitFileSet(struct soap *soap, const char *tag, struct __ns2__CommitFileSet *a, const char *type)
{
	size_t soap_flag_ns1__CommitFileSet = 1;
	short soap_flag;
	a = (struct __ns2__CommitFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__CommitFileSet, sizeof(struct __ns2__CommitFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CommitFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CommitFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CommitFileSet(soap, "ns1:CommitFileSet", &a->ns1__CommitFileSet, ""))
				{	soap_flag_ns1__CommitFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__CommitFileSet * SOAP_FMAC4 soap_instantiate___ns2__CommitFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CommitFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__CommitFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__CommitFileSet);
		if (size)
			*size = sizeof(struct __ns2__CommitFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__CommitFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__CommitFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__CommitFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CommitFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CommitFileSet %p -> %p\n", q, p));
	*(struct __ns2__CommitFileSet*)p = *(struct __ns2__CommitFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__DeleteFileSet(struct soap *soap, struct __ns2__DeleteFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__DeleteFileSet(struct soap *soap, const struct __ns2__DeleteFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteFileSet(soap, &a->ns1__DeleteFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__DeleteFileSet(struct soap *soap, const struct __ns2__DeleteFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__DeleteFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__DeleteFileSet(struct soap *soap, const char *tag, int id, const struct __ns2__DeleteFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteFileSet(soap, "ns1:DeleteFileSet", -1, &a->ns1__DeleteFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__DeleteFileSet * SOAP_FMAC4 soap_get___ns2__DeleteFileSet(struct soap *soap, struct __ns2__DeleteFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__DeleteFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__DeleteFileSet * SOAP_FMAC4 soap_in___ns2__DeleteFileSet(struct soap *soap, const char *tag, struct __ns2__DeleteFileSet *a, const char *type)
{
	size_t soap_flag_ns1__DeleteFileSet = 1;
	short soap_flag;
	a = (struct __ns2__DeleteFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__DeleteFileSet, sizeof(struct __ns2__DeleteFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__DeleteFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteFileSet(soap, "ns1:DeleteFileSet", &a->ns1__DeleteFileSet, ""))
				{	soap_flag_ns1__DeleteFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__DeleteFileSet * SOAP_FMAC4 soap_instantiate___ns2__DeleteFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__DeleteFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__DeleteFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__DeleteFileSet);
		if (size)
			*size = sizeof(struct __ns2__DeleteFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__DeleteFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__DeleteFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__DeleteFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__DeleteFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__DeleteFileSet %p -> %p\n", q, p));
	*(struct __ns2__DeleteFileSet*)p = *(struct __ns2__DeleteFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__QureyFileSet(struct soap *soap, struct __ns2__QureyFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QureyFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__QureyFileSet(struct soap *soap, const struct __ns2__QureyFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__QureyFileSet(soap, &a->ns1__QureyFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__QureyFileSet(struct soap *soap, const struct __ns2__QureyFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__QureyFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__QureyFileSet(struct soap *soap, const char *tag, int id, const struct __ns2__QureyFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__QureyFileSet(soap, "ns1:QureyFileSet", -1, &a->ns1__QureyFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__QureyFileSet * SOAP_FMAC4 soap_get___ns2__QureyFileSet(struct soap *soap, struct __ns2__QureyFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__QureyFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__QureyFileSet * SOAP_FMAC4 soap_in___ns2__QureyFileSet(struct soap *soap, const char *tag, struct __ns2__QureyFileSet *a, const char *type)
{
	size_t soap_flag_ns1__QureyFileSet = 1;
	short soap_flag;
	a = (struct __ns2__QureyFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__QureyFileSet, sizeof(struct __ns2__QureyFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__QureyFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QureyFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QureyFileSet(soap, "ns1:QureyFileSet", &a->ns1__QureyFileSet, ""))
				{	soap_flag_ns1__QureyFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__QureyFileSet * SOAP_FMAC4 soap_instantiate___ns2__QureyFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__QureyFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__QureyFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__QureyFileSet);
		if (size)
			*size = sizeof(struct __ns2__QureyFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__QureyFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__QureyFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__QureyFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__QureyFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__QureyFileSet %p -> %p\n", q, p));
	*(struct __ns2__QureyFileSet*)p = *(struct __ns2__QureyFileSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CreateFileSet(struct soap *soap, struct __ns2__CreateFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateFileSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CreateFileSet(struct soap *soap, const struct __ns2__CreateFileSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CreateFileSet(soap, &a->ns1__CreateFileSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CreateFileSet(struct soap *soap, const struct __ns2__CreateFileSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CreateFileSet(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CreateFileSet(struct soap *soap, const char *tag, int id, const struct __ns2__CreateFileSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateFileSet(soap, "ns1:CreateFileSet", -1, &a->ns1__CreateFileSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CreateFileSet * SOAP_FMAC4 soap_get___ns2__CreateFileSet(struct soap *soap, struct __ns2__CreateFileSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CreateFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__CreateFileSet * SOAP_FMAC4 soap_in___ns2__CreateFileSet(struct soap *soap, const char *tag, struct __ns2__CreateFileSet *a, const char *type)
{
	size_t soap_flag_ns1__CreateFileSet = 1;
	short soap_flag;
	a = (struct __ns2__CreateFileSet *)soap_id_enter(soap, "", a, SOAP_TYPE_FSM___ns2__CreateFileSet, sizeof(struct __ns2__CreateFileSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CreateFileSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateFileSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateFileSet(soap, "ns1:CreateFileSet", &a->ns1__CreateFileSet, ""))
				{	soap_flag_ns1__CreateFileSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__CreateFileSet * SOAP_FMAC4 soap_instantiate___ns2__CreateFileSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CreateFileSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM___ns2__CreateFileSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns2__CreateFileSet);
		if (size)
			*size = sizeof(struct __ns2__CreateFileSet);
	}
	else
	{	cp->ptr = (void*)new (struct __ns2__CreateFileSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__CreateFileSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__CreateFileSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CreateFileSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CreateFileSet %p -> %p\n", q, p));
	*(struct __ns2__CreateFileSet*)p = *(struct __ns2__CreateFileSet*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CommitErrorResponse(struct soap *soap, _ns1__CommitErrorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CommitErrorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CommitErrorResponse(struct soap *soap, _ns1__CommitErrorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CommitErrorResponse);
	if (soap_out_PointerTo_ns1__CommitErrorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CommitErrorResponse(struct soap *soap, const char *tag, int id, _ns1__CommitErrorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CommitErrorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CommitErrorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CommitErrorResponse(struct soap *soap, _ns1__CommitErrorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CommitErrorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CommitErrorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CommitErrorResponse(struct soap *soap, const char *tag, _ns1__CommitErrorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CommitErrorResponse **)soap_malloc(soap, sizeof(_ns1__CommitErrorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CommitErrorResponse *)soap_instantiate__ns1__CommitErrorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CommitErrorResponse ** p = (_ns1__CommitErrorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CommitErrorResponse, sizeof(_ns1__CommitErrorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CommitError(struct soap *soap, _ns1__CommitError *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CommitError))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CommitError(struct soap *soap, _ns1__CommitError *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CommitError);
	if (soap_out_PointerTo_ns1__CommitError(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CommitError(struct soap *soap, const char *tag, int id, _ns1__CommitError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CommitError);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CommitError ** SOAP_FMAC4 soap_get_PointerTo_ns1__CommitError(struct soap *soap, _ns1__CommitError **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CommitError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CommitError ** SOAP_FMAC4 soap_in_PointerTo_ns1__CommitError(struct soap *soap, const char *tag, _ns1__CommitError **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CommitError **)soap_malloc(soap, sizeof(_ns1__CommitError *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CommitError *)soap_instantiate__ns1__CommitError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CommitError ** p = (_ns1__CommitError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CommitError, sizeof(_ns1__CommitError), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CommitFileResponse(struct soap *soap, _ns1__CommitFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CommitFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CommitFileResponse(struct soap *soap, _ns1__CommitFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CommitFileResponse);
	if (soap_out_PointerTo_ns1__CommitFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CommitFileResponse(struct soap *soap, const char *tag, int id, _ns1__CommitFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CommitFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CommitFileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CommitFileResponse(struct soap *soap, _ns1__CommitFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CommitFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CommitFileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CommitFileResponse(struct soap *soap, const char *tag, _ns1__CommitFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CommitFileResponse **)soap_malloc(soap, sizeof(_ns1__CommitFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CommitFileResponse *)soap_instantiate__ns1__CommitFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CommitFileResponse ** p = (_ns1__CommitFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CommitFileResponse, sizeof(_ns1__CommitFileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CommitFile(struct soap *soap, _ns1__CommitFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CommitFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CommitFile(struct soap *soap, _ns1__CommitFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CommitFile);
	if (soap_out_PointerTo_ns1__CommitFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CommitFile(struct soap *soap, const char *tag, int id, _ns1__CommitFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CommitFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CommitFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__CommitFile(struct soap *soap, _ns1__CommitFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CommitFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CommitFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__CommitFile(struct soap *soap, const char *tag, _ns1__CommitFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CommitFile **)soap_malloc(soap, sizeof(_ns1__CommitFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CommitFile *)soap_instantiate__ns1__CommitFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CommitFile ** p = (_ns1__CommitFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CommitFile, sizeof(_ns1__CommitFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ProgressNotifyResponse(struct soap *soap, _ns1__ProgressNotifyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ProgressNotifyResponse(struct soap *soap, _ns1__ProgressNotifyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotifyResponse);
	if (soap_out_PointerTo_ns1__ProgressNotifyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ProgressNotifyResponse(struct soap *soap, const char *tag, int id, _ns1__ProgressNotifyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ProgressNotifyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ProgressNotifyResponse(struct soap *soap, _ns1__ProgressNotifyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ProgressNotifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ProgressNotifyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ProgressNotifyResponse(struct soap *soap, const char *tag, _ns1__ProgressNotifyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ProgressNotifyResponse **)soap_malloc(soap, sizeof(_ns1__ProgressNotifyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ProgressNotifyResponse *)soap_instantiate__ns1__ProgressNotifyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ProgressNotifyResponse ** p = (_ns1__ProgressNotifyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__ProgressNotifyResponse, sizeof(_ns1__ProgressNotifyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ProgressNotify(struct soap *soap, _ns1__ProgressNotify *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__ProgressNotify))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ProgressNotify(struct soap *soap, _ns1__ProgressNotify *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__ProgressNotify);
	if (soap_out_PointerTo_ns1__ProgressNotify(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ProgressNotify(struct soap *soap, const char *tag, int id, _ns1__ProgressNotify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__ProgressNotify);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ProgressNotify ** SOAP_FMAC4 soap_get_PointerTo_ns1__ProgressNotify(struct soap *soap, _ns1__ProgressNotify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ProgressNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ProgressNotify ** SOAP_FMAC4 soap_in_PointerTo_ns1__ProgressNotify(struct soap *soap, const char *tag, _ns1__ProgressNotify **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ProgressNotify **)soap_malloc(soap, sizeof(_ns1__ProgressNotify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ProgressNotify *)soap_instantiate__ns1__ProgressNotify(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ProgressNotify ** p = (_ns1__ProgressNotify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__ProgressNotify, sizeof(_ns1__ProgressNotify), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CommitFileSetResponse(struct soap *soap, _ns1__CommitFileSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CommitFileSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CommitFileSetResponse(struct soap *soap, _ns1__CommitFileSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSetResponse);
	if (soap_out_PointerTo_ns1__CommitFileSetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CommitFileSetResponse(struct soap *soap, const char *tag, int id, _ns1__CommitFileSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CommitFileSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CommitFileSetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CommitFileSetResponse(struct soap *soap, _ns1__CommitFileSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CommitFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CommitFileSetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CommitFileSetResponse(struct soap *soap, const char *tag, _ns1__CommitFileSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CommitFileSetResponse **)soap_malloc(soap, sizeof(_ns1__CommitFileSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CommitFileSetResponse *)soap_instantiate__ns1__CommitFileSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CommitFileSetResponse ** p = (_ns1__CommitFileSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CommitFileSetResponse, sizeof(_ns1__CommitFileSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CommitFileSet(struct soap *soap, _ns1__CommitFileSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CommitFileSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CommitFileSet(struct soap *soap, _ns1__CommitFileSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CommitFileSet);
	if (soap_out_PointerTo_ns1__CommitFileSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CommitFileSet(struct soap *soap, const char *tag, int id, _ns1__CommitFileSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CommitFileSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CommitFileSet ** SOAP_FMAC4 soap_get_PointerTo_ns1__CommitFileSet(struct soap *soap, _ns1__CommitFileSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CommitFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CommitFileSet ** SOAP_FMAC4 soap_in_PointerTo_ns1__CommitFileSet(struct soap *soap, const char *tag, _ns1__CommitFileSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CommitFileSet **)soap_malloc(soap, sizeof(_ns1__CommitFileSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CommitFileSet *)soap_instantiate__ns1__CommitFileSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CommitFileSet ** p = (_ns1__CommitFileSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CommitFileSet, sizeof(_ns1__CommitFileSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteFileSetResponse(struct soap *soap, _ns1__DeleteFileSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteFileSetResponse(struct soap *soap, _ns1__DeleteFileSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSetResponse);
	if (soap_out_PointerTo_ns1__DeleteFileSetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteFileSetResponse(struct soap *soap, const char *tag, int id, _ns1__DeleteFileSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteFileSetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteFileSetResponse(struct soap *soap, _ns1__DeleteFileSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__DeleteFileSetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteFileSetResponse(struct soap *soap, const char *tag, _ns1__DeleteFileSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteFileSetResponse **)soap_malloc(soap, sizeof(_ns1__DeleteFileSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteFileSetResponse *)soap_instantiate__ns1__DeleteFileSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteFileSetResponse ** p = (_ns1__DeleteFileSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__DeleteFileSetResponse, sizeof(_ns1__DeleteFileSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteFileSet(struct soap *soap, _ns1__DeleteFileSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__DeleteFileSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteFileSet(struct soap *soap, _ns1__DeleteFileSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__DeleteFileSet);
	if (soap_out_PointerTo_ns1__DeleteFileSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteFileSet(struct soap *soap, const char *tag, int id, _ns1__DeleteFileSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__DeleteFileSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteFileSet ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteFileSet(struct soap *soap, _ns1__DeleteFileSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__DeleteFileSet ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteFileSet(struct soap *soap, const char *tag, _ns1__DeleteFileSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteFileSet **)soap_malloc(soap, sizeof(_ns1__DeleteFileSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteFileSet *)soap_instantiate__ns1__DeleteFileSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteFileSet ** p = (_ns1__DeleteFileSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__DeleteFileSet, sizeof(_ns1__DeleteFileSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QureyFileSetResponse(struct soap *soap, _ns1__QureyFileSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__QureyFileSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QureyFileSetResponse(struct soap *soap, _ns1__QureyFileSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSetResponse);
	if (soap_out_PointerTo_ns1__QureyFileSetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QureyFileSetResponse(struct soap *soap, const char *tag, int id, _ns1__QureyFileSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__QureyFileSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QureyFileSetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__QureyFileSetResponse(struct soap *soap, _ns1__QureyFileSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QureyFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__QureyFileSetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__QureyFileSetResponse(struct soap *soap, const char *tag, _ns1__QureyFileSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QureyFileSetResponse **)soap_malloc(soap, sizeof(_ns1__QureyFileSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QureyFileSetResponse *)soap_instantiate__ns1__QureyFileSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__QureyFileSetResponse ** p = (_ns1__QureyFileSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__QureyFileSetResponse, sizeof(_ns1__QureyFileSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QureyFileSet(struct soap *soap, _ns1__QureyFileSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__QureyFileSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QureyFileSet(struct soap *soap, _ns1__QureyFileSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__QureyFileSet);
	if (soap_out_PointerTo_ns1__QureyFileSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QureyFileSet(struct soap *soap, const char *tag, int id, _ns1__QureyFileSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__QureyFileSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QureyFileSet ** SOAP_FMAC4 soap_get_PointerTo_ns1__QureyFileSet(struct soap *soap, _ns1__QureyFileSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QureyFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__QureyFileSet ** SOAP_FMAC4 soap_in_PointerTo_ns1__QureyFileSet(struct soap *soap, const char *tag, _ns1__QureyFileSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QureyFileSet **)soap_malloc(soap, sizeof(_ns1__QureyFileSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QureyFileSet *)soap_instantiate__ns1__QureyFileSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__QureyFileSet ** p = (_ns1__QureyFileSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__QureyFileSet, sizeof(_ns1__QureyFileSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateFileSetResponse(struct soap *soap, _ns1__CreateFileSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CreateFileSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateFileSetResponse(struct soap *soap, _ns1__CreateFileSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSetResponse);
	if (soap_out_PointerTo_ns1__CreateFileSetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateFileSetResponse(struct soap *soap, const char *tag, int id, _ns1__CreateFileSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CreateFileSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateFileSetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateFileSetResponse(struct soap *soap, _ns1__CreateFileSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateFileSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CreateFileSetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateFileSetResponse(struct soap *soap, const char *tag, _ns1__CreateFileSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateFileSetResponse **)soap_malloc(soap, sizeof(_ns1__CreateFileSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateFileSetResponse *)soap_instantiate__ns1__CreateFileSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CreateFileSetResponse ** p = (_ns1__CreateFileSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CreateFileSetResponse, sizeof(_ns1__CreateFileSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateFileSet(struct soap *soap, _ns1__CreateFileSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM__ns1__CreateFileSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateFileSet(struct soap *soap, _ns1__CreateFileSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTo_ns1__CreateFileSet);
	if (soap_out_PointerTo_ns1__CreateFileSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateFileSet(struct soap *soap, const char *tag, int id, _ns1__CreateFileSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM__ns1__CreateFileSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateFileSet ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateFileSet(struct soap *soap, _ns1__CreateFileSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateFileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__CreateFileSet ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateFileSet(struct soap *soap, const char *tag, _ns1__CreateFileSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateFileSet **)soap_malloc(soap, sizeof(_ns1__CreateFileSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateFileSet *)soap_instantiate__ns1__CreateFileSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CreateFileSet ** p = (_ns1__CreateFileSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM__ns1__CreateFileSet, sizeof(_ns1__CreateFileSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FileSet(struct soap *soap, ns1__FileSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_ns1__FileSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FileSet(struct soap *soap, ns1__FileSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTons1__FileSet);
	if (soap_out_PointerTons1__FileSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FileSet(struct soap *soap, const char *tag, int id, ns1__FileSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_ns1__FileSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__FileSet ** SOAP_FMAC4 soap_get_PointerTons1__FileSet(struct soap *soap, ns1__FileSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FileSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__FileSet ** SOAP_FMAC4 soap_in_PointerTons1__FileSet(struct soap *soap, const char *tag, ns1__FileSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FileSet **)soap_malloc(soap, sizeof(ns1__FileSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FileSet *)soap_instantiate_ns1__FileSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__FileSet ** p = (ns1__FileSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_ns1__FileSet, sizeof(ns1__FileSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__File(struct soap *soap, ns1__File *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_ns1__File))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__File(struct soap *soap, ns1__File *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTons1__File);
	if (soap_out_PointerTons1__File(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__File(struct soap *soap, const char *tag, int id, ns1__File *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_ns1__File);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__File ** SOAP_FMAC4 soap_get_PointerTons1__File(struct soap *soap, ns1__File **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__File(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__File ** SOAP_FMAC4 soap_in_PointerTons1__File(struct soap *soap, const char *tag, ns1__File **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__File **)soap_malloc(soap, sizeof(ns1__File *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__File *)soap_instantiate_ns1__File(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__File ** p = (ns1__File **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_ns1__File, sizeof(ns1__File), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfFile(struct soap *soap, ns1__ArrayOfFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_ns1__ArrayOfFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfFile(struct soap *soap, ns1__ArrayOfFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTons1__ArrayOfFile);
	if (soap_out_PointerTons1__ArrayOfFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfFile(struct soap *soap, const char *tag, int id, ns1__ArrayOfFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_ns1__ArrayOfFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfFile ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfFile(struct soap *soap, ns1__ArrayOfFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfFile ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfFile(struct soap *soap, const char *tag, ns1__ArrayOfFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfFile **)soap_malloc(soap, sizeof(ns1__ArrayOfFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfFile *)soap_instantiate_ns1__ArrayOfFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfFile ** p = (ns1__ArrayOfFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_ns1__ArrayOfFile, sizeof(ns1__ArrayOfFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_FSM_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_FSM_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FSM_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_FSM__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_FSM__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_FSM_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FSM_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_FSM_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_FSM_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__File(struct soap *soap, std::vector<ns1__File * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__File(struct soap *soap, const std::vector<ns1__File * >*a)
{
	for (std::vector<ns1__File * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__File(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__File(struct soap *soap, const char *tag, int id, const std::vector<ns1__File * >*a, const char *type)
{
	for (std::vector<ns1__File * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__File(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__File * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__File(struct soap *soap, const char *tag, std::vector<ns1__File * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__File(soap, -1)))
		return NULL;
	ns1__File *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_FSM_ns1__File, SOAP_TYPE_FSM_std__vectorTemplateOfPointerTons1__File, sizeof(ns1__File), 1))
				break;
			if (!soap_in_PointerTons1__File(soap, tag, NULL, "ns1:File"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__File(soap, tag, &n, "ns1:File"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__File * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__File(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__File(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FSM_std__vectorTemplateOfPointerTons1__File, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::vector<ns1__File * >);
		if (size)
			*size = sizeof(std::vector<ns1__File * >);
	}
	else
	{	cp->ptr = (void*)new (std::vector<ns1__File * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__File * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__File * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__File(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__File * > %p -> %p\n", q, p));
	*(std::vector<ns1__File * >*)p = *(std::vector<ns1__File * >*)q;
}

} // namespace FSM


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of FSMC.cpp */
